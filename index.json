[{"content":"","date":"2025年3月19日","externalUrl":null,"permalink":"/","section":"raikiriww's blog","summary":"","title":"raikiriww's blog","type":"page"},{"content":" def test(): print(\u0026#34;test\u0026#34;) ","date":"2025年3月19日","externalUrl":null,"permalink":"/test/","section":"raikiriww's blog","summary":"","title":"test","type":"page"},{"content":"","date":"2024年10月16日","externalUrl":null,"permalink":"/tags/android/","section":"Tags","summary":"","title":"Android","type":"tags"},{"content":"最近在进行一些 Android app 蓝牙相关的开发，需要前台长时间高频率的扫描 BLE 设备，使用了 Android 提供的 SCAN_MODE_LOW_LATENCY 扫描模式，扫描 30 分钟后出现了扫描不到 BLE 设备的情况。\n问题 # 使用自己开发的 Android app ，蓝牙扫描代码为：\nimport android.bluetooth.le.BluetoothLeScanner; import android.bluetooth.le.ScanCallback; import android.bluetooth.le.ScanSettings; public class BluetoothScanManager { private static BluetoothLeScanner bluetoothLeScanner; private static ScanCallback scanCallback; private static ScanSettings scanSettings; public BluetoothScanManager(BluetoothLeScanner bluetoothLeScanner, ScanCallback scanCallback) { BluetoothScanManager.bluetoothLeScanner = bluetoothLeScanner; BluetoothScanManager.scanCallback = scanCallback; BluetoothScanManager.scanSettings = new ScanSettings.Builder() .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY) .setCallbackType(ScanSettings.CALLBACK_TYPE_ALL_MATCHES) .build(); } private static void startScan() { bluetoothLeScanner.startScan(null, scanSettings, scanCallback); } private static void stopScan() { bluetoothLeScanner.stopScan(scanCallback); } } 使用的测试手机的 Android 版本为 7.0 。程序开始扫描的前 30 分钟可以正常的高频扫描到 BLE 设备，30 分钟后一个 BLE 设备也扫描不到了。\n查找原因 # 根据搜索引擎检索到的相关信息查看 Android 蓝牙相关源码，在 180 行找到了处理 BLE 扫描操作的类：\n// Handler class that handles BLE scan operations. private class ClientHandler extends Handler { 其中用来接收消息的函数为：\n@Override public void handleMessage(Message msg) { ScanClient client = (ScanClient) msg.obj; switch (msg.what) { case MSG_START_BLE_SCAN: handleStartScan(client); break; case MSG_STOP_BLE_SCAN: handleStopScan(client); break; case MSG_FLUSH_BATCH_RESULTS: handleFlushBatchResults(client); break; case MSG_SCAN_TIMEOUT: mScanNative.regularScanTimeout(); break; default: // Shouldn\u0026#39;t happen. Log.e(TAG, \u0026#34;received an unkown message : \u0026#34; + msg.what); } } 当收到开始 BLE 扫描的信号后会执行 handleStartScan 函数：\nvoid handleStartScan(ScanClient client) { Utils.enforceAdminPermission(mService); logd(\u0026#34;handling starting scan\u0026#34;); if (!isScanSupported(client)) { Log.e(TAG, \u0026#34;Scan settings not supported\u0026#34;); return; } if (mRegularScanClients.contains(client) || mBatchClients.contains(client)) { Log.e(TAG, \u0026#34;Scan already started\u0026#34;); return; } // Begin scan operations. if (isBatchClient(client)) { mBatchClients.add(client); mScanNative.startBatchScan(client); } else { mRegularScanClients.add(client); mScanNative.startRegularScan(client); if (!mScanNative.isOpportunisticScanClient(client)) { mScanNative.configureRegularScanParams(); if (!mScanNative.isFirstMatchScanClient(client)) { Message msg = mHandler.obtainMessage(MSG_SCAN_TIMEOUT); msg.obj = client; // Only one timeout message should exist at any time mHandler.removeMessages(SCAN_TIMEOUT_MS); mHandler.sendMessageDelayed(msg, SCAN_TIMEOUT_MS); } } // Update BatteryStats with this workload. try { mBatteryStats.noteBleScanStarted(client.workSource); } catch (RemoteException e) { /* ignore */ } } } 其中重要的是 // Begin scan operations 的 else 代码块中的第二个 if 代码块 ，首先会进行一个 isFirstMatchScanClient 函数的判断。函数在 531 行：\nprivate boolean isFirstMatchScanClient(ScanClient client) { return (client.settings.getCallbackType() \u0026amp; ScanSettings.CALLBACK_TYPE_FIRST_MATCH) != 0; } 这个函数会将 client 的 CallbackType 和 ScanSettings.CALLBACK_TYPE_FIRST_MATCH 进行比对看是否一致，不一致的话会创建一个超时消息并使用 sendMessageDelayed 函数延迟 SCAN_TIMEOUT_MS 后发送。SCAN_TIMEOUT_MS 的值在 72 行：\n// Maximum msec before scan gets downgraded to opportunistic private static final int SCAN_TIMEOUT_MS = 30 * 60 * 1000; 这个值就和遇到的 30 分钟后扫描不到 BLE 设备对上了。这个延迟 30 分钟后发送的消息会触发上面的 handleMessage 中的\ncase MSG_SCAN_TIMEOUT: mScanNative.regularScanTimeout(); break; regularScanTimeout 函数在 674 行：\nvoid regularScanTimeout() { for (ScanClient client : mRegularScanClients) { if (!isOpportunisticScanClient(client) \u0026amp;\u0026amp; !isFirstMatchScanClient(client)) { logd(\u0026#34;clientIf set to scan opportunisticly: \u0026#34; + client.clientIf); setOpportunisticScanClient(client); client.stats.setScanTimeout(); } } // The scan should continue for background scans configureRegularScanParams(); if (numRegularScanClients() == 0) { logd(\u0026#34;stop scan\u0026#34;); gattClientScanNative(false); } } void setOpportunisticScanClient(ScanClient client) { // TODO: Add constructor to ScanSettings.Builder // that can copy values from an existing ScanSettings object ScanSettings.Builder builder = new ScanSettings.Builder(); ScanSettings settings = client.settings; builder.setScanMode(ScanSettings.SCAN_MODE_OPPORTUNISTIC); builder.setCallbackType(settings.getCallbackType()); builder.setScanResultType(settings.getScanResultType()); builder.setReportDelay(settings.getReportDelayMillis()); builder.setNumOfMatches(settings.getNumOfMatches()); client.settings = builder.build(); } 可以看到 regularScanTimeout 会把我们的蓝牙扫描模式设置为 ScanSettings.SCAN_MODE_OPPORTUNISTIC 。Android developer 的文档对这个扫描模式的描述为：\nA special Bluetooth LE scan mode. Applications using this scan mode will passively listen for other scan results without starting BLE scans themselves.\n根据文档，这种模式仅在其他应用已经启用了蓝牙扫描的情况下才会工作。也就是说，扫描不会主动进行，只会依赖其他应用的扫描行为。\n至此，问题基本查清了。总结一下，当我们设置的 BLE 扫描的 CallbackType 不为 ScanSettings.CALLBACK_TYPE_FIRST_MATCH 时，BLE 的 ScanManager 会自动为我们 BLE 扫描的 client 增加一个 30 分钟后的超时消息发送，这个超时消息会改变我们的蓝牙扫描模式并把我们 BLE 扫描的 client 的状态设置为超时，导致我们搜索不到 BLE 设备。\n解决方式 # 由于这个 30 分钟的限制只针对我们 BLE 扫描的 client 。所以我们可以在开始扫描的同时创建一个定时任务，在一段时间（\u0026lt;30 分钟），比如 29 分钟后停止蓝牙扫描，等待一秒，然后再开始蓝牙扫描。大概代码为：\nimport android.bluetooth.le.BluetoothLeScanner; import android.bluetooth.le.ScanCallback; import android.bluetooth.le.ScanSettings; import android.os.Handler; import android.os.Looper; public class BluetoothScanManager { private static BluetoothLeScanner bluetoothLeScanner; private static ScanCallback scanCallback; private static ScanSettings scanSettings; private static Handler handler; private static final long SCAN_DURATION = 29 * 60 * 1000; // 29 minutes in milliseconds public BluetoothScanManager(BluetoothLeScanner bluetoothLeScanner, ScanCallback scanCallback) { BluetoothScanManager.bluetoothLeScanner = bluetoothLeScanner; BluetoothScanManager.scanCallback = scanCallback; BluetoothScanManager.handler = new Handler(Looper.getMainLooper()); BluetoothScanManager.scanSettings = new ScanSettings.Builder() .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY) .build(); } private static void startScan() { bluetoothLeScanner.startScan(null, scanSettings, scanCallback); handler.postDelayed(() -\u0026gt; { stopScan(); handler.postDelayed(BluetoothScanManager::startScan, 1000); // Wait 1 second before restarting scan }, SCAN_DURATION); } private static void stopScan() { bluetoothLeScanner.stopScan(scanCallback); } } 修改后测试了两个小时，可以不间断的搜索到 BLE 设备。具体的 SCAN_DURATION 可能会根据不同厂商或不同安卓版本来修改。目前最新的 main 分支上的相关代码做了修改，但这个参数的值并没有变，详见 AdapterService.java 。\n为什么会有这个限制 # AOSP code review system 上增加这个限制的 commit 消息为：\nAdd protection against LE scanning abuse\nAdded two checks to prevent abuse. The first check ensures that an app doesn\u0026rsquo;t scan too frequently in a certain time period. It is allowed to scan again after its oldest scan exceedes said time period. The second check ensures that an app doesn\u0026rsquo;t scan for too long. Upon starting a scan, this code waits a certain amount of time. If the app is still scanning by that point, this code stops the scan and forces the app to use opportunistic scanning instead.\n看来是为了防止 BLE 扫描的滥用。而且一开始的超时时间设置的为 5 分钟，后边的一次提交才改为 30 分钟。但这些限制并没有在开发者文档中相关的地方标注出来。\n参考链接 # https://juejin.cn/post/7046328465108402207 https://blog.classycode.com/undocumented-android-7-ble-behavior-changes-d1a9bd87d983 ","date":"2024年10月16日","externalUrl":null,"permalink":"/posts/android-ble-long-term-high-frequency-scanning/","section":"Posts","summary":"\u003cp\u003e最近在进行一些 Android app 蓝牙相关的开发，需要前台长时间高频率的扫描 BLE 设备，使用了 Android 提供的 \u003ccode\u003eSCAN_MODE_LOW_LATENCY\u003c/code\u003e 扫描模式，扫描 30 分钟后出现了扫描不到 BLE 设备的情况。\u003c/p\u003e","title":"Android BLE 长时间高频率扫描","type":"posts"},{"content":"","date":"2024年10月16日","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2024年10月16日","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2024年3月3日","externalUrl":null,"permalink":"/tags/socat/","section":"Tags","summary":"","title":"Socat","type":"tags"},{"content":"","date":"2024年3月3日","externalUrl":null,"permalink":"/tags/windows/","section":"Tags","summary":"","title":"Windows","type":"tags"},{"content":"最近在自己家中的迷你主机上部署了一些自己用的服务，使用 frp 做内网穿透将迷你主机的服务映射到公网供自己使用。frp 支持 SSH 的端口复用，但需要使用到 Socat 这个工具。Socat 在 linux 和 mac 环境下都可以使用命令直接下载使用，但 windows 没有现成的库，网上找到的都是别人自己编译，也不知道靠不靠谱，所以决定使用 Github action 全自动，透明的编译一版 windows 能直接用的 Socat 。目前已经做好了，项目地址：https://github.com/raikiriww/socat_windows 。\n项目介绍 # 整个项目目前（2024-03-03）只有一个 readme 和 Github action 的执行文件。具体为：\nname: Cygwin Build on: # Triggers the workflow on push or pull request events but only for the \u0026#34;main\u0026#34; branch push: branches: [ \u0026#34;main\u0026#34; ] pull_request: branches: [ \u0026#34;main\u0026#34; ] # Allows you to run this workflow manually from the Actions tab workflow_dispatch: jobs: build: permissions: write-all runs-on: windows-latest steps: - uses: actions/checkout@v2 - name: Install Cygwin run: | choco install cygwin choco install cyg-get cyg-get gcc-g++ gcc-core cygwin32-gcc-g++ cygwin32-gcc-core make gcc-fortran gcc-objc gcc-objc++ libkrb5-devel libkrb5_3 libreadline-devel libssl-devel libwrap-devel tcp_wrappers - name: Configure Environment run: | echo \u0026#34;C:\\tools\\cygwin\\bin\u0026#34; \u0026gt;\u0026gt; $GITHUB_PATH - name: Download and Extract the archive run: | curl -O http://www.dest-unreach.org/socat/download/socat-1.8.0.0.tar.gz tar -xvzf socat-1.8.0.0.tar.gz - name: Execute Build Script in Cygwin run: | C:\\tools\\cygwin\\bin\\bash -lc \u0026#34;cd /cygdrive/d/a/socat_windows/socat_windows/socat-1.8.0.0 \u0026amp;\u0026amp; ./configure \u0026amp;\u0026amp; make \u0026amp;\u0026amp; make install\u0026#34; - name: Copy Cygwin DLLs run: | Copy-Item \u0026#34;C:\\tools\\cygwin\\bin\\cygcrypto-3.dll\u0026#34; -Destination \u0026#34;D:\\a\\socat_windows\\socat_windows\\socat-1.8.0.0\u0026#34; Copy-Item \u0026#34;C:\\tools\\cygwin\\bin\\cygwin1.dll\u0026#34; -Destination \u0026#34;D:\\a\\socat_windows\\socat_windows\\socat-1.8.0.0\u0026#34; Copy-Item \u0026#34;C:\\tools\\cygwin\\bin\\cygssl-3.dll\u0026#34; -Destination \u0026#34;D:\\a\\socat_windows\\socat_windows\\socat-1.8.0.0\u0026#34; Copy-Item \u0026#34;C:\\tools\\cygwin\\bin\\cygreadline7.dll\u0026#34; -Destination \u0026#34;D:\\a\\socat_windows\\socat_windows\\socat-1.8.0.0\u0026#34; Copy-Item \u0026#34;C:\\tools\\cygwin\\bin\\cygwrap-0.dll\u0026#34; -Destination \u0026#34;D:\\a\\socat_windows\\socat_windows\\socat-1.8.0.0\u0026#34; Copy-Item \u0026#34;C:\\tools\\cygwin\\bin\\cygncursesw-10.dll\u0026#34; -Destination \u0026#34;D:\\a\\socat_windows\\socat_windows\\socat-1.8.0.0\u0026#34; Copy-Item \u0026#34;C:\\tools\\cygwin\\bin\\cygz.dll\u0026#34; -Destination \u0026#34;D:\\a\\socat_windows\\socat_windows\\socat-1.8.0.0\u0026#34; shell: pwsh - name: Upload Artifacts if: ${{ success() }} uses: actions/upload-artifact@v2 with: name: socat-1.8.0.0 path: socat-1.8.0.0/ - name: Archive production artifacts if: ${{ success() }} run: 7z a socat-1.8.0.0.zip D:\\a\\socat_windows\\socat_windows\\socat-1.8.0.0 - name: Upload Release uses: softprops/action-gh-release@v1 if: ${{ success() }} with: tag_name: 1.8.0.0 files: socat-1.8.0.0.zip 整个编译过程在 Github 的 windows runner 上执行。使用 Cygwin 作为编译工具。编译过程分为下面几步：\n初始化代码仓库。这步会将仓库的所有文件下载到 runner 中。 安装 Cygwin 和依赖的库。 将 Cygwin 的 bin 目录加到环境变量中。 下载 Socat 的源码。 使用 Cygwin 编译。 拷贝依赖的 dll 文件到编译好的程序目录。 打包编译好的程序作为 Artifact 。 将打包好的压缩包作为 Release 发布。 使用方法 # 下载项目 Releases 页面的程序压缩包。解压到本地。 将解压好的文件夹路径添加到 windows 的 PATH 环境变量中。 打开终端输入 socat 即可使用。编译好的程序在我自己的电脑上（windows11 22H2 22621.2506）运行良好。\n","date":"2024年3月3日","externalUrl":null,"permalink":"/posts/windows-using-socat/","section":"Posts","summary":"\u003cp\u003e最近在自己家中的迷你主机上部署了一些自己用的服务，使用 frp 做内网穿透将迷你主机的服务映射到公网供自己使用。frp 支持 SSH 的端口复用，但需要使用到 Socat 这个工具。Socat 在 linux 和 mac 环境下都可以使用命令直接下载使用，但 windows 没有现成的库，网上找到的都是别人自己编译，也不知道靠不靠谱，所以决定使用 Github action 全自动，透明的编译一版 windows 能直接用的 Socat 。目前已经做好了，项目地址：\u003ca href=\"https://github.com/raikiriww/socat_windows\" target=\"_blank\"\u003ehttps://github.com/raikiriww/socat_windows\u003c/a\u003e 。\u003c/p\u003e","title":"Windows 系统使用 Socat","type":"posts"},{"content":"","date":"2023年10月20日","externalUrl":null,"permalink":"/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","section":"Tags","summary":"","title":"博客搭建","type":"tags"},{"content":"利用 Github Actions 来自动构建和部署博客到 Github Pages。这样既可以简化自己的操作，又能保证自己的博客源码的私密性。\nGithub token # 具体位置为：个人设置界面 -\u0026gt; Developer Settings -\u0026gt; Personal access tokens -\u0026gt; Tokens(classic) 在此界面新生成一个 token，需要勾选 repo 和 workflow 选项。Expiration 可以设置为 No expiration。创建完成后会显示你的 token，它只会显示这一次，你需要将它记下来，后边会用到。。\nworkflow 文件 # 想利用 Github Actions，需要在博客的根目录下创建 .github/workflows/ 文件夹。在该文件夹下创建 yml 文件会被 Github Actions 执行。\n我的 workflow 文件如下：\nname: GitHub Pages on: push: branches: - main # Set a branch to deploy release: types: - published jobs: deploy: runs-on: ubuntu-20.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v3 with: ref: main - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.119.0\u0026#39; # 是否启用 hugo extend # extended: true - name: Build run: hugo --minify - name: Deploy run: | cd ./public git init git config --global user.name \u0026#39;${{ secrets.GITHUBUSERNAME }}\u0026#39; git config --global user.email \u0026#39;${{ secrets.GITHUBEMAIL }}\u0026#39; git add . git commit -m \u0026#34;${{ github.event.head_commit.message }}\u0026#34; git push --force --quiet \u0026#34;https://${{ secrets.GITHUBUSERNAME }}:${{ secrets.GITHUBTOKEN }}@github.com/${{ secrets.GITHUBUSERNAME }}/${{ secrets.GITHUBUSERNAME }}.github.io.git\u0026#34; master:main #git push --force --quiet \u0026#34;https://${{ secrets.TOKENUSER }}:${{ secrets.CODINGTOKEN }}@e.coding.net/${{ secrets.CODINGUSERNAME }}/${{ secrets.CODINGBLOGREPO }}.git\u0026#34; master:master #coding 部署写法，需要的自行取消注释 #git push --force --quiet \u0026#34;https://${{ secrets.GITEEUSERNAME }}:${{ secrets.GITEETOKEN }}@gitee.com/${{ secrets.GITEEUSERNAME }}/${{ secrets.GITEEUSERNAME }}.git\u0026#34; master:master #gitee 部署写法，需要的自行取消注释 其中，GITHUBUSERNAME ，GITHUBEMAIL ， GITHUBTOKEN 三个为自定义变量，后边会讲到。\n源码仓库 # 新建或使用一个老的仓库，可见性设置为 private。在代码仓库的 Settings 页面找到 Secrets and variables ，点击其中的 Actions ，添加 workflow 中用到的三个变量：GITHUBUSERNAME ，GITHUBEMAIL ， GITHUBTOKEN 。\n上传代码 # 完成上述步骤后即可用 git 提交代码到你的源码仓库，即可在仓库的 Actions 界面看到执行的 workflows。\n参考 # 整体结构 部署部分 ","date":"2023年10月20日","externalUrl":null,"permalink":"/posts/auto-deploy-blog-with-github-actions/","section":"Posts","summary":"\u003cp\u003e利用 Github Actions 来自动构建和部署博客到 Github Pages。这样既可以简化自己的操作，又能保证自己的博客源码的私密性。\u003c/p\u003e","title":"使用 Github Actions 自动部署博客","type":"posts"},{"content":"","date":"2023年10月11日","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":"公司有一个同事做的项目，其中有一个 Python 写的程序会反复降低 CPU 的电压直至死机重启，程序会在降压前保存本次的数据。听起来很合理，先保存数据再降低电压，如果死机了导致重启，那上次的数据也保存到本地了。但在 windows 电脑上实际运行时，每次程序导致 windows 死机重启后，保存的数据文件都为空。他没搞定这个就离职了，于是我就接手来查这个 bug 了。\n查找问题 # 大概的代码示例如下：\n# 写入文件 with open(file_path, \u0026#34;w\u0026#34;) as f: f.write(some_data) logging.warning(\u0026#34;Write to checkpoint file\u0026#34;) # 降低 CPU 电压，过低会导致死机 set_voltage_offset(v_off) 从代码结构来看确实没什么问题，是先保存数据再降低电压，即使后边的操作导致死机也是在写入操作完成后，应该不会影响保存的数据才对。但事实是确实有影响，在 windows 上测试了好几次保存的数据都为空。with open() 语句是 Python 中常用的文件操作语句，不应该会导致写入异常，于是怀疑是降压操作导致的。\n分析问题 # 在 Python 中，当使用 with open() 语句来写入文件时，它会负责管理文件的打开和关闭，通常情况下， with 语句块结束后，Python 会自动关闭文件，并确保所有数据写入硬盘。但，这个操作不是立即发生的。\n当写入文件时，操作系统通常会缓存这些操作，以便一次性的将多个写入操作合并，从而提高效率。这意味着即使 Python 代码执行了写入操作（也就是 write()），也不能保证这些数据已经永久的保存到了硬盘上。如果在 with 语句块结束后立即死机，这些数据可能会丢失。\n解决方法 # 现在知道了导致数据保存失败的原因是出在 windows 的系统缓存机制上，那只要找到方法可以强制系统将缓存的数据写入硬盘就好了。修改后的代码如下：\n# 写入文件 with open(file_path, \u0026#34;w\u0026#34;) as f: f.write(some_data) # 确保数据从 Python 的内部缓冲区写入操作系统的缓冲区 f.flush() # 确保数据从操作系统的缓冲区写入磁盘 os.fsync(f.fileno()) logging.warning(\u0026#34;Write to checkpoint file\u0026#34;) # 降低 CPU 电压，过低会导致死机 set_voltage_offset(v_off) 新增了两行代码。\nf.flush() 的作用为刷新 Python 的内部缓冲区，确保所有数据写入操作系统的缓冲区。但这个并不能保证操作系统会立刻将数据写入硬盘。 os.fsync(f.fileno()) 的作用为强制操作系统将其缓冲区的数据写入硬盘。这样就保证了如果之后的代码导致系统死机，这部分数据也会完整的保存在硬盘上。 将修改后的程序在 windows 上测试，数据每次都会完整的保存在硬盘上。\n后记 # 在 Microsoft 的一篇官方文档中有提到 disk write caching ，也就是写入缓存，并给出了关闭的方法。\n关于 disk write caching ，官方的描述为：\nAdditionally, turning disk write caching on may increase operating system performance; however, it may also result in the loss of information if a power failure, equipment failure, or software failure occurs.\n确实与我遇到的情况一样。\n还有一篇更详细一点的介绍：https://learn.microsoft.com/en-US/windows/client-management/client-tools/change-default-removal-policy-external-storage-media\n总的来说 disk write caching 在一般情况下可以提高性能。但在需要确保极端情况下写入数据完整性时，可以考虑关闭或者手动强制写入。\n","date":"2023年10月11日","externalUrl":null,"permalink":"/posts/python-write-file-failed/","section":"Posts","summary":"\u003cp\u003e公司有一个同事做的项目，其中有一个 Python 写的程序会反复降低 CPU 的电压直至死机重启，程序会在降压前保存本次的数据。听起来很合理，先保存数据再降低电压，如果死机了导致重启，那上次的数据也保存到本地了。但在 windows 电脑上实际运行时，每次程序导致 windows 死机重启后，保存的数据文件都为空。他没搞定这个就离职了，于是我就接手来查这个 bug 了。\u003c/p\u003e","title":"Python 写入文件失败","type":"posts"},{"content":"","date":"2023年10月11日","externalUrl":null,"permalink":"/tags/%E6%8A%80%E6%9C%AF/","section":"Tags","summary":"","title":"技术","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]